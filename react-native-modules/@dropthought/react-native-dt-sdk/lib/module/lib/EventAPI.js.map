{"version":3,"names":["isNil","isEmpty","fetcherInstance","throwRequestError","EVENT_PATH","apiPostEvent","programId","feedbacks","source","metadata","createdTime","timeZone","axiosConfig","fetcher","params","method","authRequired","data","refId","map","feedback","dataId","questionId","dataValue","answers","dataType","type","otherFlag","metaData","request","then","response","success"],"sources":["EventAPI.js"],"sourcesContent":["/**\n * @description\n * https://docs.dropthought.com/docs/2_0/api.html#event\n * submit feedback\n */\nimport {isNil, isEmpty} from 'ramda'\n\nimport {fetcherInstance} from './APIClient'\nimport {throwRequestError} from './Fetcher'\n\nconst EVENT_PATH = '/api/event'\n\n/**\n * post event (feedback)\n * @param {{\n *   programId: string,\n *   feedbacks: Feedback[],\n *   source?: EventAPISourceType,\n *   metadata: any,\n *   createdTime: string,\n *   timeZone: string\n * }} param0\n * @param {AxiosRequestConfig} axiosConfig\n * @param {Fetcher=} fetcher\n * @returns {Promise<Survey>}\n */\nexport async function apiPostEvent(\n    {programId, feedbacks = [], source = 'api', metadata = {}, createdTime, timeZone},\n    axiosConfig = {},\n    fetcher = fetcherInstance,\n) {\n    /** @type {AxiosRequestConfig} */\n    const params = {\n        method: 'POST',\n        authRequired: true,\n        data: {\n        refId: programId,\n        data: feedbacks.map((feedback) => ({\n                dataId: feedback.questionId,\n                dataValue:\n                    // for not answered question, server doesn't allow empty array for dataValue\n                    // it accept [''] for not answered question\n                    isNil(feedback.answers) || isEmpty(feedback.answers)\n                        ? ['']\n                        : feedback.answers,\n                dataType: feedback.type,\n                otherFlag: feedback.otherFlag,\n            })),\n            metaData: {\n                source,\n                ...metadata,\n            },\n            createdTime,\n            timeZone,\n        },\n        ...axiosConfig,\n    }\n\n    return fetcher.request(EVENT_PATH, params).then((response) => {\n        if (response.data.success === false) {\n            throwRequestError(response)\n            return\n        }\n        return response.data\n    })\n}\n\n/**\n * @typedef {import('./Fetcher').RequestConfig} RequestConfig\n * @typedef {import('./Fetcher').Fetcher} Fetcher\n * @typedef {import('../data').Feedback} Feedback\n * @typedef {import('../data').SurveyFeedback} SurveyFeedback\n * @typedef {import('../data').EventAPISourceType} EventAPISourceType\n */\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,SAAQA,KAAK,EAAEC,OAAO,QAAO,OAAO;AAEpC,SAAQC,eAAe,QAAO,aAAa;AAC3C,SAAQC,iBAAiB,QAAO,WAAW;AAE3C,MAAMC,UAAU,GAAG,YAAY;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeC,YAAYA,CAC9B;EAACC,SAAS;EAAEC,SAAS,GAAG,EAAE;EAAEC,MAAM,GAAG,KAAK;EAAEC,QAAQ,GAAG,CAAC,CAAC;EAAEC,WAAW;EAAEC;AAAQ,CAAC,EACjFC,WAAW,GAAG,CAAC,CAAC,EAChBC,OAAO,GAAGX,eAAe,EAC3B;EACE;EACA,MAAMY,MAAM,GAAG;IACXC,MAAM,EAAE,MAAM;IACdC,YAAY,EAAE,IAAI;IAClBC,IAAI,EAAE;MACNC,KAAK,EAAEZ,SAAS;MAChBW,IAAI,EAAEV,SAAS,CAACY,GAAG,CAAEC,QAAQ,KAAM;QAC3BC,MAAM,EAAED,QAAQ,CAACE,UAAU;QAC3BC,SAAS;QACL;QACA;QACAvB,KAAK,CAACoB,QAAQ,CAACI,OAAO,CAAC,IAAIvB,OAAO,CAACmB,QAAQ,CAACI,OAAO,CAAC,GAC9C,CAAC,EAAE,CAAC,GACJJ,QAAQ,CAACI,OAAO;QAC1BC,QAAQ,EAAEL,QAAQ,CAACM,IAAI;QACvBC,SAAS,EAAEP,QAAQ,CAACO;MACxB,CAAC,CAAC,CAAC;MACHC,QAAQ,EAAE;QACNpB,MAAM;QACN,GAAGC;MACP,CAAC;MACDC,WAAW;MACXC;IACJ,CAAC;IACD,GAAGC;EACP,CAAC;EAED,OAAOC,OAAO,CAACgB,OAAO,CAACzB,UAAU,EAAEU,MAAM,CAAC,CAACgB,IAAI,CAAEC,QAAQ,IAAK;IAC1D,IAAIA,QAAQ,CAACd,IAAI,CAACe,OAAO,KAAK,KAAK,EAAE;MACjC7B,iBAAiB,CAAC4B,QAAQ,CAAC;MAC3B;IACJ;IACA,OAAOA,QAAQ,CAACd,IAAI;EACxB,CAAC,CAAC;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA"}