{"version":3,"sources":["Fetcher.js"],"names":["RENEW_ENDPOINT","DT_API_KEY_HEADER","DEFAULT_TIMEOUT","throwRequestError","mockAxiosResponse","response","name","message","data","error","status","isRequestTimeoutError","isNoInternetError","isTokenValid","jwtToken","jwtPayload","Date","now","exp","e","console","log","setRequestHeader","requestConfig","header","headers","restRequestConfig","Fetcher","constructor","param","baseURL","timeout","Promise","resolve","undefined","url","init","authToken","apiKey","refreshToken","storeTokens","loadCache","saveCache","defaultRequestConfig","fetchWithTimeout","abortController","AbortController","cancelTimeout","timeoutId","setTimeout","abort","params","Object","keys","filter","key","map","encodeURIComponent","join","fetchURL","fetch","method","body","JSON","stringify","signal","then","r","isJSONContent","get","indexOf","value","entries","json","text","statusText","toString","catch","err","finally","clearTimeout","authorizeConfig","token","Authorization","tokenRenew","renewTokenIfNeeded","accessToken","request","authRequired","cache","result"],"mappings":"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","sourcesContent":["import { NativeModule } from 'react-native';\nimport jwtDecode from 'jwt-decode';\nimport { isNil, pick } from 'ramda';\n\nconst RENEW_ENDPOINT = '/api/token/renew';\nconst DT_API_KEY_HEADER = 'X-DT-API-KEY';\n\nconst DEFAULT_TIMEOUT = 30000; // default timeout: 30 seconds\n\n/**\n * @param {import('axios').AxiosResponse<any>} mockAxiosResponse\n */\nexport const throwRequestError = (mockAxiosResponse) => {\n  throw {\n    response: mockAxiosResponse,\n    name: 'RequestError',\n    message:\n      mockAxiosResponse.data.error ||\n      `Request failed with status code ${mockAxiosResponse.status}`,\n  };\n};\n\n/**\n * @param {Error} error\n */\nexport const isRequestTimeoutError = (error) => error.name === 'RequestTimeout';\n\n/**\n * @param {Error} error\n */\nexport const isNoInternetError = (error) =>\n  error.message === 'Network request failed';\n\nconst isTokenValid = (jwtToken) => {\n  let jwtPayload;\n\n  // decode token\n  try {\n    jwtPayload = jwtDecode(jwtToken);\n\n    // check expiration date\n    if (Date.now() >= jwtPayload.exp * 1000) {\n      return false;\n    } else {\n      return jwtPayload;\n    }\n  } catch (e) {\n    console.log('decode jwt failed', e);\n    return false;\n  }\n};\n\n/**\n * @param {RequestConfig} requestConfig\n * @param {object} header\n * @returns {RequestConfig}\n */\nconst setRequestHeader = (requestConfig, header = {}) => {\n  const { headers = {}, ...restRequestConfig } = requestConfig;\n  return {\n    headers: {\n      ...headers,\n      ...header,\n    },\n    ...restRequestConfig,\n  };\n};\n\n/**\n * @typedef {object}  InitializeParams\n * @property {string=} baseURL optional, if want to overwrite the baseURL\n * @property {number=} timeout optional, if want to overwrite the default timeout\n * @property {()=>Promise<string>=} authToken - optional, a function that returns the auth token or api-key\n * @property {()=>Promise<string>=} refreshToken - optional, a function that returns the refresh token\n * @property {(authTokens: AuthToken)=>Promise<any>=} storeTokens - optional, a function that tells the engine how to store tokens\n * @property {(url: string)=>Promise<any>=} loadCache - optional, a function that tells the engine how to load cache from this url\n * @property {(url: string, response: {data: any, status: number, statusText: string, headers: object})=>Promise<any>=} saveCache - optional, a function that tells the engine how to save cache\n * @property {string=} apiKey - or simply given the apiKey, optional\n */\nexport class Fetcher {\n  defaultRequestConfig = {\n    baseURL: '',\n    timeout: DEFAULT_TIMEOUT,\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n    },\n  };\n\n  /** @type {() => Promise<string>} */\n  authToken = () => Promise.resolve(undefined);\n\n  /** @type {string | undefined} this is for api key version2 */\n  apiKey = undefined;\n\n  /** @type {() => Promise<string>} */\n  refreshToken = () => Promise.resolve(undefined);\n\n  /** @type {(authTokens: AuthToken) => Promise<undefined>} */\n  storeTokens = () => Promise.resolve(undefined);\n\n  /**\n   * @template T\n   * @type {(url: string) => Promise<T>}\n   */\n  loadCache = (url) => Promise.resolve(undefined);\n\n  /** @type {(url: string, response: {data: any, status: number, statusText: string}) => Promise<undefined>} */\n  saveCache = (url, response) => Promise.resolve(undefined);\n\n  /**\n   * @param {InitializeParams} param\n   */\n  constructor(param = {}) {\n    this.init(param);\n  }\n\n  /**\n   * @param {InitializeParams} param\n   */\n  init(param = {}) {\n    const {\n      baseURL,\n      timeout,\n      authToken,\n      apiKey,\n      refreshToken,\n      storeTokens,\n      loadCache,\n      saveCache,\n    } = param;\n\n    if (baseURL) {\n      this.defaultRequestConfig.baseURL = baseURL;\n    }\n    if (!isNil(timeout)) {\n      this.defaultRequestConfig.timeout = timeout;\n    }\n\n    if (authToken) {\n      this.authToken = authToken;\n    } else if (apiKey) {\n      this.apiKey = apiKey;\n      this.authToken = () => Promise.resolve(undefined);\n    }\n\n    if (refreshToken) {\n      this.refreshToken = refreshToken;\n    }\n\n    if (storeTokens) {\n      this.storeTokens = storeTokens;\n    }\n\n    if (loadCache) {\n      this.loadCache = loadCache;\n    }\n\n    if (saveCache) {\n      this.saveCache = saveCache;\n    }\n  }\n\n  /**\n   * @template T\n   * @param {string} url\n   * @param {RequestConfig} requestConfig\n   * @returns {import('axios').AxiosPromise<T>}\n   */\n  async fetchWithTimeout(url, requestConfig) {\n    // setting fetch abort (it is supported after RN 0.60)\n    // eslint-disable-next-line no-undef\n    const abortController = new AbortController();\n    const cancelTimeout =\n      requestConfig.timeout ||\n      this.defaultRequestConfig.timeout ||\n      DEFAULT_TIMEOUT;\n    const timeoutId = setTimeout(() => {\n      abortController.abort();\n    }, cancelTimeout);\n\n    // compose fetch params\n    const params = Object.keys(requestConfig.params || {})\n      .filter((key) => !isNil(requestConfig.params[key]))\n      .map((key) => `${key}=${encodeURIComponent(requestConfig.params[key])}`)\n      .join('&');\n    // compose fetch full URL\n    const fetchURL =\n      (requestConfig.baseURL || this.defaultRequestConfig.baseURL) +\n      url +\n      `?${params}`;\n\n    return await fetch(fetchURL, {\n      method: requestConfig.method || 'GET',\n      headers: {\n        ...this.defaultRequestConfig.headers,\n        ...requestConfig.headers,\n      },\n      body: requestConfig.body || JSON.stringify(requestConfig.data),\n      signal: abortController.signal,\n    })\n      .then(async (r) => {\n        const isJSONContent =\n          r.headers.get('content-type').indexOf('application/json') !== -1;\n\n        const headers = {};\n        if (r.headers) {\n          for (const [key, value] of r.headers.entries()) {\n            headers[key] = value;\n          }\n        }\n\n        /** @type {import('axios').AxiosResponse<any>} */\n        let mockAxiosResponse = {};\n        mockAxiosResponse.status = r.status;\n        mockAxiosResponse.data = isJSONContent\n          ? await r.json()\n          : await r.text();\n        mockAxiosResponse.headers = headers;\n        mockAxiosResponse.statusText = r.status.toString();\n\n        if (r.status >= 200 && r.status < 300) {\n          return mockAxiosResponse;\n        }\n        throwRequestError(mockAxiosResponse);\n      })\n      .catch((err) => {\n        if (err.name === 'AbortError' || err.message === 'Aborted') {\n          throw {\n            name: 'RequestTimeout',\n            message: `Request Timeout of ${cancelTimeout}ms.`,\n          };\n        }\n        throw err;\n      })\n      .finally(() => {\n        // clear timeout when request is final, success or failed\n        clearTimeout(timeoutId);\n      });\n  }\n\n  /**\n   * set the auth token to config\n   * @private\n   * @param {RequestConfig} requestConfig\n   * @returns {Promise<RequestConfig>}\n   */\n  async authorizeConfig(requestConfig) {\n    if (this.apiKey) {\n      return setRequestHeader(requestConfig, {\n        [DT_API_KEY_HEADER]: this.apiKey,\n      });\n    }\n    const token = await this.authToken();\n    if (!token) return requestConfig;\n\n    return setRequestHeader(requestConfig, {\n      Authorization: `Bearer ${token}`,\n    });\n  }\n\n  /** @returns {Promise<any>} */\n  async tokenRenew(timeout = DEFAULT_TIMEOUT) {\n    const refreshToken = await this.refreshToken();\n    if (!refreshToken) return;\n\n    return this.fetchWithTimeout(RENEW_ENDPOINT, {\n      method: 'POST',\n      data: {\n        refreshToken,\n      },\n      timeout,\n    }).then((response) => {\n      return this.storeTokens(response.data);\n    });\n  }\n\n  /**\n   * it checks if the authToken(accessToken) is valid (check the expiration date)\n   * if it is invalid, renew token\n   * @private\n   * @param {number=} timeout\n   */\n  async renewTokenIfNeeded(timeout) {\n    const refreshToken = await this.refreshToken();\n    if (!refreshToken) return;\n\n    const accessToken = await this.authToken();\n    if (!accessToken) return;\n\n    if (!isTokenValid(accessToken)) {\n      try {\n        await this.tokenRenew(timeout);\n      } catch (e) {\n        console.log('token renew failed', e.message);\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * @public\n   * @template T\n   * @param {string} url\n   * @param {RequestConfig} requestConfig\n   * @returns {import('axios').AxiosPromise<T>}\n   */\n  async request(url, requestConfig) {\n    let authRequired = false;\n\n    if (requestConfig.headers?.Authorization || requestConfig.authRequired) {\n      authRequired = true;\n\n      // refresh token before sending out actual request\n      await this.renewTokenIfNeeded(requestConfig.timeout);\n      requestConfig = await this.authorizeConfig(requestConfig);\n    }\n\n    // read cached response\n    if (requestConfig.cache) {\n      const result = await this.loadCache(url);\n      if (result) return result;\n    }\n\n    // if auth is required, but there's no authorization, fail early before making a request\n    if (authRequired && !requestConfig.headers?.Authorization && !this.apiKey) {\n      return throwRequestError({\n        status: 401,\n        statusText: '401',\n        data: {},\n        headers: {},\n      });\n    }\n\n    let response = await this.fetchWithTimeout(url, requestConfig);\n\n    // if this request is authRequired and the response status is 401, try to renew token again\n    if (authRequired && response.status === 401 && !this.apiKey) {\n      await this.tokenRenew(requestConfig.timeout);\n\n      // query again with renewed token\n      requestConfig = await this.authorizeConfig(requestConfig);\n      response = await this.fetchWithTimeout(url, requestConfig);\n    }\n\n    // store response if cache is true\n    if (requestConfig.cache) {\n      await this.saveCache(\n        url,\n        pick(['data', 'status', 'statusText', 'headers'], response)\n      );\n    }\n\n    return response;\n  }\n}\n\n/**\n * @typedef {Object} AuthToken\n * @property {string} accessToken\n * @property {string} refreshToken\n */\n\n/**\n * @typedef {Object} CustomRequestConfig\n * @property {boolean} authRequired\n * @property {boolean} cache\n */\n\n/**\n * @typedef {import('axios').AxiosRequestConfig & CustomRequestConfig} RequestConfig\n */\n"]}